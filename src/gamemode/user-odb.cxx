// This file was generated by ODB, object-relational mapping (ORM)
// compiler for C++.
//

#include <odb/pre.hxx>

#include "user-odb.hxx"

#include <cassert>
#include <cstring>  // std::memcpy

#include <odb/schema-catalog-impl.hxx>

#include <odb/sqlite/traits.hxx>
#include <odb/sqlite/database.hxx>
#include <odb/sqlite/transaction.hxx>
#include <odb/sqlite/connection.hxx>
#include <odb/sqlite/statement.hxx>
#include <odb/sqlite/statement-cache.hxx>
#include <odb/sqlite/simple-object-statements.hxx>
#include <odb/sqlite/container-statements.hxx>
#include <odb/sqlite/exceptions.hxx>
#include <odb/sqlite/simple-object-result.hxx>

namespace odb
{
  // user
  //

  struct access::object_traits_impl< ::user, id_sqlite >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      sqlite::connection&,
      image_type&,
      id_image_type&,
      sqlite::binding&,
      sqlite::binding&)
    {
    }
  };

  access::object_traits_impl< ::user, id_sqlite >::id_type
  access::object_traits_impl< ::user, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        id,
        i.nickname_value,
        i.nickname_size,
        i.nickname_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::user, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // displayname_
    //
    if (t[0UL])
    {
      i.displayname_value.capacity (i.displayname_size);
      grew = true;
    }

    // password_
    //
    if (t[1UL])
    {
      i.password_value.capacity (i.password_size);
      grew = true;
    }

    // money_
    //
    t[2UL] = false;

    // score_
    //
    t[3UL] = false;

    // kills_
    //
    t[4UL] = false;

    // experience_
    //
    t[5UL] = false;

    // deaths_
    //
    t[6UL] = false;

    // privilidges_
    //
    t[7UL] = false;

    // bounty_
    //
    t[8UL] = false;

    // suicides_
    //
    t[9UL] = false;

    // respect_
    //
    t[10UL] = false;

    // kicks_
    //
    t[11UL] = false;

    // warns_
    //
    t[12UL] = false;

    // playtime_
    //
    t[13UL] = false;

    // banned_
    //
    t[14UL] = false;

    // ban_reason_
    //
    if (t[15UL])
    {
      i.ban_reason_value.capacity (i.ban_reason_size);
      grew = true;
    }

    // ban_who_
    //
    if (t[16UL])
    {
      i.ban_who_value.capacity (i.ban_who_size);
      grew = true;
    }

    // bannedip_
    //
    t[17UL] = false;

    // bannedidentificator_
    //
    t[18UL] = false;

    // jailtime_
    //
    t[19UL] = false;

    // registertime_
    //
    t[20UL] = false;

    // email_
    //
    if (t[21UL])
    {
      i.email_value.capacity (i.email_size);
      grew = true;
    }

    // SkinModelID_
    //
    t[22UL] = false;

    // Premium_
    //
    t[23UL] = false;

    // lastconnected_
    //
    t[24UL] = false;

    // MafiaName_
    //
    if (t[25UL])
    {
      i.MafiaName_value.capacity (i.MafiaName_size);
      grew = true;
    }

    // UseMafiaSkin_
    //
    t[26UL] = false;

    // UseMafiaSpawn_
    //
    t[27UL] = false;

    // rampid_
    //
    t[28UL] = false;

    // SaveX_
    //
    t[29UL] = false;

    // SaveY_
    //
    t[30UL] = false;

    // SaveZ_
    //
    t[31UL] = false;

    // SaveA_
    //
    t[32UL] = false;

    // staticcolor_
    //
    t[33UL] = false;

    // bank_
    //
    t[34UL] = false;

    // registerip_
    //
    if (t[35UL])
    {
      i.registerip_value.capacity (i.registerip_size);
      grew = true;
    }

    // lastip_
    //
    if (t[36UL])
    {
      i.lastip_value.capacity (i.lastip_size);
      grew = true;
    }

    // recoverycode_
    //
    if (t[37UL])
    {
      i.recoverycode_value.capacity (i.recoverycode_size);
      grew = true;
    }

    // mailverifiedtime_
    //
    t[38UL] = false;

    // lastmailsent_
    //
    t[39UL] = false;

    // verifiedmail_
    //
    if (t[40UL])
    {
      i.verifiedmail_value.capacity (i.verifiedmail_size);
      grew = true;
    }

    // verificationsent_
    //
    t[41UL] = false;

    // verifiedrecoverycode_
    //
    if (t[42UL])
    {
      i.verifiedrecoverycode_value.capacity (i.verifiedrecoverycode_size);
      grew = true;
    }

    // PrivateCars_
    //
    if (t[43UL])
    {
      i.PrivateCars_value.capacity (i.PrivateCars_size);
      grew = true;
    }

    // achievementdata_
    //
    if (t[44UL])
    {
      i.achievementdata_value.capacity (i.achievementdata_size);
      grew = true;
    }

    // weapondata_
    //
    if (t[45UL])
    {
      i.weapondata_value.capacity (i.weapondata_size);
      grew = true;
    }

    // nickname_
    //
    if (t[46UL])
    {
      i.nickname_value.capacity (i.nickname_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::user, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // displayname_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.displayname_value.data ();
    b[n].size = &i.displayname_size;
    b[n].capacity = i.displayname_value.capacity ();
    b[n].is_null = &i.displayname_null;
    n++;

    // password_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.password_value.data ();
    b[n].size = &i.password_size;
    b[n].capacity = i.password_value.capacity ();
    b[n].is_null = &i.password_null;
    n++;

    // money_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.money_value;
    b[n].is_null = &i.money_null;
    n++;

    // score_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.score_value;
    b[n].is_null = &i.score_null;
    n++;

    // kills_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.kills_value;
    b[n].is_null = &i.kills_null;
    n++;

    // experience_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.experience_value;
    b[n].is_null = &i.experience_null;
    n++;

    // deaths_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.deaths_value;
    b[n].is_null = &i.deaths_null;
    n++;

    // privilidges_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.privilidges_value;
    b[n].is_null = &i.privilidges_null;
    n++;

    // bounty_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.bounty_value;
    b[n].is_null = &i.bounty_null;
    n++;

    // suicides_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.suicides_value;
    b[n].is_null = &i.suicides_null;
    n++;

    // respect_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.respect_value;
    b[n].is_null = &i.respect_null;
    n++;

    // kicks_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.kicks_value;
    b[n].is_null = &i.kicks_null;
    n++;

    // warns_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.warns_value;
    b[n].is_null = &i.warns_null;
    n++;

    // playtime_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.playtime_value;
    b[n].is_null = &i.playtime_null;
    n++;

    // banned_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.banned_value;
    b[n].is_null = &i.banned_null;
    n++;

    // ban_reason_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.ban_reason_value.data ();
    b[n].size = &i.ban_reason_size;
    b[n].capacity = i.ban_reason_value.capacity ();
    b[n].is_null = &i.ban_reason_null;
    n++;

    // ban_who_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.ban_who_value.data ();
    b[n].size = &i.ban_who_size;
    b[n].capacity = i.ban_who_value.capacity ();
    b[n].is_null = &i.ban_who_null;
    n++;

    // bannedip_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.bannedip_value;
    b[n].is_null = &i.bannedip_null;
    n++;

    // bannedidentificator_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.bannedidentificator_value;
    b[n].is_null = &i.bannedidentificator_null;
    n++;

    // jailtime_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.jailtime_value;
    b[n].is_null = &i.jailtime_null;
    n++;

    // registertime_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.registertime_value;
    b[n].is_null = &i.registertime_null;
    n++;

    // email_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.email_value.data ();
    b[n].size = &i.email_size;
    b[n].capacity = i.email_value.capacity ();
    b[n].is_null = &i.email_null;
    n++;

    // SkinModelID_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.SkinModelID_value;
    b[n].is_null = &i.SkinModelID_null;
    n++;

    // Premium_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.Premium_value;
    b[n].is_null = &i.Premium_null;
    n++;

    // lastconnected_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lastconnected_value;
    b[n].is_null = &i.lastconnected_null;
    n++;

    // MafiaName_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.MafiaName_value.data ();
    b[n].size = &i.MafiaName_size;
    b[n].capacity = i.MafiaName_value.capacity ();
    b[n].is_null = &i.MafiaName_null;
    n++;

    // UseMafiaSkin_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.UseMafiaSkin_value;
    b[n].is_null = &i.UseMafiaSkin_null;
    n++;

    // UseMafiaSpawn_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.UseMafiaSpawn_value;
    b[n].is_null = &i.UseMafiaSpawn_null;
    n++;

    // rampid_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.rampid_value;
    b[n].is_null = &i.rampid_null;
    n++;

    // SaveX_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.SaveX_value;
    b[n].is_null = &i.SaveX_null;
    n++;

    // SaveY_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.SaveY_value;
    b[n].is_null = &i.SaveY_null;
    n++;

    // SaveZ_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.SaveZ_value;
    b[n].is_null = &i.SaveZ_null;
    n++;

    // SaveA_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.SaveA_value;
    b[n].is_null = &i.SaveA_null;
    n++;

    // staticcolor_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.staticcolor_value;
    b[n].is_null = &i.staticcolor_null;
    n++;

    // bank_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.bank_value;
    b[n].is_null = &i.bank_null;
    n++;

    // registerip_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.registerip_value.data ();
    b[n].size = &i.registerip_size;
    b[n].capacity = i.registerip_value.capacity ();
    b[n].is_null = &i.registerip_null;
    n++;

    // lastip_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.lastip_value.data ();
    b[n].size = &i.lastip_size;
    b[n].capacity = i.lastip_value.capacity ();
    b[n].is_null = &i.lastip_null;
    n++;

    // recoverycode_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.recoverycode_value.data ();
    b[n].size = &i.recoverycode_size;
    b[n].capacity = i.recoverycode_value.capacity ();
    b[n].is_null = &i.recoverycode_null;
    n++;

    // mailverifiedtime_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.mailverifiedtime_value;
    b[n].is_null = &i.mailverifiedtime_null;
    n++;

    // lastmailsent_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lastmailsent_value;
    b[n].is_null = &i.lastmailsent_null;
    n++;

    // verifiedmail_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.verifiedmail_value.data ();
    b[n].size = &i.verifiedmail_size;
    b[n].capacity = i.verifiedmail_value.capacity ();
    b[n].is_null = &i.verifiedmail_null;
    n++;

    // verificationsent_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.verificationsent_value;
    b[n].is_null = &i.verificationsent_null;
    n++;

    // verifiedrecoverycode_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.verifiedrecoverycode_value.data ();
    b[n].size = &i.verifiedrecoverycode_size;
    b[n].capacity = i.verifiedrecoverycode_value.capacity ();
    b[n].is_null = &i.verifiedrecoverycode_null;
    n++;

    // PrivateCars_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.PrivateCars_value.data ();
    b[n].size = &i.PrivateCars_size;
    b[n].capacity = i.PrivateCars_value.capacity ();
    b[n].is_null = &i.PrivateCars_null;
    n++;

    // achievementdata_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.achievementdata_value.data ();
    b[n].size = &i.achievementdata_size;
    b[n].capacity = i.achievementdata_value.capacity ();
    b[n].is_null = &i.achievementdata_null;
    n++;

    // weapondata_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.weapondata_value.data ();
    b[n].size = &i.weapondata_size;
    b[n].capacity = i.weapondata_value.capacity ();
    b[n].is_null = &i.weapondata_null;
    n++;

    // nickname_
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::image_traits<
        ::std::string,
        sqlite::id_text>::bind_value;
      b[n].buffer = i.nickname_value.data ();
      b[n].size = &i.nickname_size;
      b[n].capacity = i.nickname_value.capacity ();
      b[n].is_null = &i.nickname_null;
      n++;
    }
  }

  void access::object_traits_impl< ::user, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.id_value.data ();
    b[n].size = &i.id_size;
    b[n].capacity = i.id_value.capacity ();
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::user, id_sqlite >::
  init (image_type& i,
        const object_type& o,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // displayname_
    //
    {
      ::std::string const& v =
        o.displayname_;

      bool is_null (false);
      std::size_t cap (i.displayname_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.displayname_value,
        i.displayname_size,
        is_null,
        v);
      i.displayname_null = is_null;
      grew = grew || (cap != i.displayname_value.capacity ());
    }

    // password_
    //
    {
      ::std::string const& v =
        o.password_;

      bool is_null (false);
      std::size_t cap (i.password_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.password_value,
        i.password_size,
        is_null,
        v);
      i.password_null = is_null;
      grew = grew || (cap != i.password_value.capacity ());
    }

    // money_
    //
    {
      long long int const& v =
        o.money_;

      bool is_null (false);
      sqlite::value_traits<
          long long int,
          sqlite::id_integer >::set_image (
        i.money_value,
        is_null,
        v);
      i.money_null = is_null;
    }

    // score_
    //
    {
      long long int const& v =
        o.score_;

      bool is_null (false);
      sqlite::value_traits<
          long long int,
          sqlite::id_integer >::set_image (
        i.score_value,
        is_null,
        v);
      i.score_null = is_null;
    }

    // kills_
    //
    {
      long long unsigned int const& v =
        o.kills_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.kills_value,
        is_null,
        v);
      i.kills_null = is_null;
    }

    // experience_
    //
    {
      long long unsigned int const& v =
        o.experience_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.experience_value,
        is_null,
        v);
      i.experience_null = is_null;
    }

    // deaths_
    //
    {
      long long unsigned int const& v =
        o.deaths_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.deaths_value,
        is_null,
        v);
      i.deaths_null = is_null;
    }

    // privilidges_
    //
    {
      long long unsigned int const& v =
        o.privilidges_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.privilidges_value,
        is_null,
        v);
      i.privilidges_null = is_null;
    }

    // bounty_
    //
    {
      long long unsigned int const& v =
        o.bounty_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.bounty_value,
        is_null,
        v);
      i.bounty_null = is_null;
    }

    // suicides_
    //
    {
      long long unsigned int const& v =
        o.suicides_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.suicides_value,
        is_null,
        v);
      i.suicides_null = is_null;
    }

    // respect_
    //
    {
      long long int const& v =
        o.respect_;

      bool is_null (false);
      sqlite::value_traits<
          long long int,
          sqlite::id_integer >::set_image (
        i.respect_value,
        is_null,
        v);
      i.respect_null = is_null;
    }

    // kicks_
    //
    {
      long long unsigned int const& v =
        o.kicks_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.kicks_value,
        is_null,
        v);
      i.kicks_null = is_null;
    }

    // warns_
    //
    {
      long long unsigned int const& v =
        o.warns_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.warns_value,
        is_null,
        v);
      i.warns_null = is_null;
    }

    // playtime_
    //
    {
      long long unsigned int const& v =
        o.playtime_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.playtime_value,
        is_null,
        v);
      i.playtime_null = is_null;
    }

    // banned_
    //
    {
      long long unsigned int const& v =
        o.banned_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.banned_value,
        is_null,
        v);
      i.banned_null = is_null;
    }

    // ban_reason_
    //
    {
      ::std::string const& v =
        o.ban_reason_;

      bool is_null (false);
      std::size_t cap (i.ban_reason_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.ban_reason_value,
        i.ban_reason_size,
        is_null,
        v);
      i.ban_reason_null = is_null;
      grew = grew || (cap != i.ban_reason_value.capacity ());
    }

    // ban_who_
    //
    {
      ::std::string const& v =
        o.ban_who_;

      bool is_null (false);
      std::size_t cap (i.ban_who_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.ban_who_value,
        i.ban_who_size,
        is_null,
        v);
      i.ban_who_null = is_null;
      grew = grew || (cap != i.ban_who_value.capacity ());
    }

    // bannedip_
    //
    {
      long unsigned int const& v =
        o.bannedip_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.bannedip_value,
        is_null,
        v);
      i.bannedip_null = is_null;
    }

    // bannedidentificator_
    //
    {
      long long unsigned int const& v =
        o.bannedidentificator_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.bannedidentificator_value,
        is_null,
        v);
      i.bannedidentificator_null = is_null;
    }

    // jailtime_
    //
    {
      long long unsigned int const& v =
        o.jailtime_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.jailtime_value,
        is_null,
        v);
      i.jailtime_null = is_null;
    }

    // registertime_
    //
    {
      long long unsigned int const& v =
        o.registertime_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.registertime_value,
        is_null,
        v);
      i.registertime_null = is_null;
    }

    // email_
    //
    {
      ::std::string const& v =
        o.email_;

      bool is_null (false);
      std::size_t cap (i.email_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.email_value,
        i.email_size,
        is_null,
        v);
      i.email_null = is_null;
      grew = grew || (cap != i.email_value.capacity ());
    }

    // SkinModelID_
    //
    {
      int const& v =
        o.SkinModelID_;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.SkinModelID_value,
        is_null,
        v);
      i.SkinModelID_null = is_null;
    }

    // Premium_
    //
    {
      long long unsigned int const& v =
        o.Premium_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.Premium_value,
        is_null,
        v);
      i.Premium_null = is_null;
    }

    // lastconnected_
    //
    {
      long long unsigned int const& v =
        o.lastconnected_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.lastconnected_value,
        is_null,
        v);
      i.lastconnected_null = is_null;
    }

    // MafiaName_
    //
    {
      ::std::string const& v =
        o.MafiaName_;

      bool is_null (false);
      std::size_t cap (i.MafiaName_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.MafiaName_value,
        i.MafiaName_size,
        is_null,
        v);
      i.MafiaName_null = is_null;
      grew = grew || (cap != i.MafiaName_value.capacity ());
    }

    // UseMafiaSkin_
    //
    {
      bool const& v =
        o.UseMafiaSkin_;

      bool is_null (false);
      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_image (
        i.UseMafiaSkin_value,
        is_null,
        v);
      i.UseMafiaSkin_null = is_null;
    }

    // UseMafiaSpawn_
    //
    {
      bool const& v =
        o.UseMafiaSpawn_;

      bool is_null (false);
      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_image (
        i.UseMafiaSpawn_value,
        is_null,
        v);
      i.UseMafiaSpawn_null = is_null;
    }

    // rampid_
    //
    {
      int const& v =
        o.rampid_;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.rampid_value,
        is_null,
        v);
      i.rampid_null = is_null;
    }

    // SaveX_
    //
    {
      float const& v =
        o.SaveX_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.SaveX_value,
        is_null,
        v);
      i.SaveX_null = is_null;
    }

    // SaveY_
    //
    {
      float const& v =
        o.SaveY_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.SaveY_value,
        is_null,
        v);
      i.SaveY_null = is_null;
    }

    // SaveZ_
    //
    {
      float const& v =
        o.SaveZ_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.SaveZ_value,
        is_null,
        v);
      i.SaveZ_null = is_null;
    }

    // SaveA_
    //
    {
      float const& v =
        o.SaveA_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.SaveA_value,
        is_null,
        v);
      i.SaveA_null = is_null;
    }

    // staticcolor_
    //
    {
      int const& v =
        o.staticcolor_;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.staticcolor_value,
        is_null,
        v);
      i.staticcolor_null = is_null;
    }

    // bank_
    //
    {
      long long int const& v =
        o.bank_;

      bool is_null (false);
      sqlite::value_traits<
          long long int,
          sqlite::id_integer >::set_image (
        i.bank_value,
        is_null,
        v);
      i.bank_null = is_null;
    }

    // registerip_
    //
    {
      ::std::string const& v =
        o.registerip_;

      bool is_null (false);
      std::size_t cap (i.registerip_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.registerip_value,
        i.registerip_size,
        is_null,
        v);
      i.registerip_null = is_null;
      grew = grew || (cap != i.registerip_value.capacity ());
    }

    // lastip_
    //
    {
      ::std::string const& v =
        o.lastip_;

      bool is_null (false);
      std::size_t cap (i.lastip_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.lastip_value,
        i.lastip_size,
        is_null,
        v);
      i.lastip_null = is_null;
      grew = grew || (cap != i.lastip_value.capacity ());
    }

    // recoverycode_
    //
    {
      ::std::string const& v =
        o.recoverycode_;

      bool is_null (false);
      std::size_t cap (i.recoverycode_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.recoverycode_value,
        i.recoverycode_size,
        is_null,
        v);
      i.recoverycode_null = is_null;
      grew = grew || (cap != i.recoverycode_value.capacity ());
    }

    // mailverifiedtime_
    //
    {
      long long unsigned int const& v =
        o.mailverifiedtime_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.mailverifiedtime_value,
        is_null,
        v);
      i.mailverifiedtime_null = is_null;
    }

    // lastmailsent_
    //
    {
      long long unsigned int const& v =
        o.lastmailsent_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.lastmailsent_value,
        is_null,
        v);
      i.lastmailsent_null = is_null;
    }

    // verifiedmail_
    //
    {
      ::std::string const& v =
        o.verifiedmail_;

      bool is_null (false);
      std::size_t cap (i.verifiedmail_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.verifiedmail_value,
        i.verifiedmail_size,
        is_null,
        v);
      i.verifiedmail_null = is_null;
      grew = grew || (cap != i.verifiedmail_value.capacity ());
    }

    // verificationsent_
    //
    {
      long long unsigned int const& v =
        o.verificationsent_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.verificationsent_value,
        is_null,
        v);
      i.verificationsent_null = is_null;
    }

    // verifiedrecoverycode_
    //
    {
      ::std::string const& v =
        o.verifiedrecoverycode_;

      bool is_null (false);
      std::size_t cap (i.verifiedrecoverycode_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.verifiedrecoverycode_value,
        i.verifiedrecoverycode_size,
        is_null,
        v);
      i.verifiedrecoverycode_null = is_null;
      grew = grew || (cap != i.verifiedrecoverycode_value.capacity ());
    }

    // PrivateCars_
    //
    {
      char const* v =
        o.PrivateCars_;

      bool is_null (false);
      std::size_t cap (i.PrivateCars_value.capacity ());
      sqlite::value_traits<
          char[720],
          sqlite::id_blob >::set_image (
        i.PrivateCars_value,
        i.PrivateCars_size,
        is_null,
        v);
      i.PrivateCars_null = is_null;
      grew = grew || (cap != i.PrivateCars_value.capacity ());
    }

    // achievementdata_
    //
    {
      char const* v =
        o.achievementdata_;

      bool is_null (false);
      std::size_t cap (i.achievementdata_value.capacity ());
      sqlite::value_traits<
          char[4096],
          sqlite::id_blob >::set_image (
        i.achievementdata_value,
        i.achievementdata_size,
        is_null,
        v);
      i.achievementdata_null = is_null;
      grew = grew || (cap != i.achievementdata_value.capacity ());
    }

    // weapondata_
    //
    {
      char const* v =
        o.weapondata_;

      bool is_null (false);
      std::size_t cap (i.weapondata_value.capacity ());
      sqlite::value_traits<
          char[440],
          sqlite::id_blob >::set_image (
        i.weapondata_value,
        i.weapondata_size,
        is_null,
        v);
      i.weapondata_null = is_null;
      grew = grew || (cap != i.weapondata_value.capacity ());
    }

    // nickname_
    //
    if (sk == statement_insert)
    {
      ::std::string const& v =
        o.nickname_;

      bool is_null (false);
      std::size_t cap (i.nickname_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.nickname_value,
        i.nickname_size,
        is_null,
        v);
      i.nickname_null = is_null;
      grew = grew || (cap != i.nickname_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::user, id_sqlite >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // displayname_
    //
    {
      ::std::string& v =
        o.displayname_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.displayname_value,
        i.displayname_size,
        i.displayname_null);
    }

    // password_
    //
    {
      ::std::string& v =
        o.password_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.password_value,
        i.password_size,
        i.password_null);
    }

    // money_
    //
    {
      long long int& v =
        o.money_;

      sqlite::value_traits<
          long long int,
          sqlite::id_integer >::set_value (
        v,
        i.money_value,
        i.money_null);
    }

    // score_
    //
    {
      long long int& v =
        o.score_;

      sqlite::value_traits<
          long long int,
          sqlite::id_integer >::set_value (
        v,
        i.score_value,
        i.score_null);
    }

    // kills_
    //
    {
      long long unsigned int& v =
        o.kills_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.kills_value,
        i.kills_null);
    }

    // experience_
    //
    {
      long long unsigned int& v =
        o.experience_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.experience_value,
        i.experience_null);
    }

    // deaths_
    //
    {
      long long unsigned int& v =
        o.deaths_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.deaths_value,
        i.deaths_null);
    }

    // privilidges_
    //
    {
      long long unsigned int& v =
        o.privilidges_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.privilidges_value,
        i.privilidges_null);
    }

    // bounty_
    //
    {
      long long unsigned int& v =
        o.bounty_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.bounty_value,
        i.bounty_null);
    }

    // suicides_
    //
    {
      long long unsigned int& v =
        o.suicides_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.suicides_value,
        i.suicides_null);
    }

    // respect_
    //
    {
      long long int& v =
        o.respect_;

      sqlite::value_traits<
          long long int,
          sqlite::id_integer >::set_value (
        v,
        i.respect_value,
        i.respect_null);
    }

    // kicks_
    //
    {
      long long unsigned int& v =
        o.kicks_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.kicks_value,
        i.kicks_null);
    }

    // warns_
    //
    {
      long long unsigned int& v =
        o.warns_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.warns_value,
        i.warns_null);
    }

    // playtime_
    //
    {
      long long unsigned int& v =
        o.playtime_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.playtime_value,
        i.playtime_null);
    }

    // banned_
    //
    {
      long long unsigned int& v =
        o.banned_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.banned_value,
        i.banned_null);
    }

    // ban_reason_
    //
    {
      ::std::string& v =
        o.ban_reason_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.ban_reason_value,
        i.ban_reason_size,
        i.ban_reason_null);
    }

    // ban_who_
    //
    {
      ::std::string& v =
        o.ban_who_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.ban_who_value,
        i.ban_who_size,
        i.ban_who_null);
    }

    // bannedip_
    //
    {
      long unsigned int& v =
        o.bannedip_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.bannedip_value,
        i.bannedip_null);
    }

    // bannedidentificator_
    //
    {
      long long unsigned int& v =
        o.bannedidentificator_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.bannedidentificator_value,
        i.bannedidentificator_null);
    }

    // jailtime_
    //
    {
      long long unsigned int& v =
        o.jailtime_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.jailtime_value,
        i.jailtime_null);
    }

    // registertime_
    //
    {
      long long unsigned int& v =
        o.registertime_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.registertime_value,
        i.registertime_null);
    }

    // email_
    //
    {
      ::std::string& v =
        o.email_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.email_value,
        i.email_size,
        i.email_null);
    }

    // SkinModelID_
    //
    {
      int& v =
        o.SkinModelID_;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.SkinModelID_value,
        i.SkinModelID_null);
    }

    // Premium_
    //
    {
      long long unsigned int& v =
        o.Premium_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.Premium_value,
        i.Premium_null);
    }

    // lastconnected_
    //
    {
      long long unsigned int& v =
        o.lastconnected_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.lastconnected_value,
        i.lastconnected_null);
    }

    // MafiaName_
    //
    {
      ::std::string& v =
        o.MafiaName_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.MafiaName_value,
        i.MafiaName_size,
        i.MafiaName_null);
    }

    // UseMafiaSkin_
    //
    {
      bool& v =
        o.UseMafiaSkin_;

      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_value (
        v,
        i.UseMafiaSkin_value,
        i.UseMafiaSkin_null);
    }

    // UseMafiaSpawn_
    //
    {
      bool& v =
        o.UseMafiaSpawn_;

      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_value (
        v,
        i.UseMafiaSpawn_value,
        i.UseMafiaSpawn_null);
    }

    // rampid_
    //
    {
      int& v =
        o.rampid_;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.rampid_value,
        i.rampid_null);
    }

    // SaveX_
    //
    {
      float& v =
        o.SaveX_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.SaveX_value,
        i.SaveX_null);
    }

    // SaveY_
    //
    {
      float& v =
        o.SaveY_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.SaveY_value,
        i.SaveY_null);
    }

    // SaveZ_
    //
    {
      float& v =
        o.SaveZ_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.SaveZ_value,
        i.SaveZ_null);
    }

    // SaveA_
    //
    {
      float& v =
        o.SaveA_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.SaveA_value,
        i.SaveA_null);
    }

    // staticcolor_
    //
    {
      int& v =
        o.staticcolor_;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.staticcolor_value,
        i.staticcolor_null);
    }

    // bank_
    //
    {
      long long int& v =
        o.bank_;

      sqlite::value_traits<
          long long int,
          sqlite::id_integer >::set_value (
        v,
        i.bank_value,
        i.bank_null);
    }

    // registerip_
    //
    {
      ::std::string& v =
        o.registerip_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.registerip_value,
        i.registerip_size,
        i.registerip_null);
    }

    // lastip_
    //
    {
      ::std::string& v =
        o.lastip_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.lastip_value,
        i.lastip_size,
        i.lastip_null);
    }

    // recoverycode_
    //
    {
      ::std::string& v =
        o.recoverycode_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.recoverycode_value,
        i.recoverycode_size,
        i.recoverycode_null);
    }

    // mailverifiedtime_
    //
    {
      long long unsigned int& v =
        o.mailverifiedtime_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.mailverifiedtime_value,
        i.mailverifiedtime_null);
    }

    // lastmailsent_
    //
    {
      long long unsigned int& v =
        o.lastmailsent_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.lastmailsent_value,
        i.lastmailsent_null);
    }

    // verifiedmail_
    //
    {
      ::std::string& v =
        o.verifiedmail_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.verifiedmail_value,
        i.verifiedmail_size,
        i.verifiedmail_null);
    }

    // verificationsent_
    //
    {
      long long unsigned int& v =
        o.verificationsent_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.verificationsent_value,
        i.verificationsent_null);
    }

    // verifiedrecoverycode_
    //
    {
      ::std::string& v =
        o.verifiedrecoverycode_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.verifiedrecoverycode_value,
        i.verifiedrecoverycode_size,
        i.verifiedrecoverycode_null);
    }

    // PrivateCars_
    //
    {
      char* v =
        o.PrivateCars_;

      sqlite::value_traits<
          char[720],
          sqlite::id_blob >::set_value (
        v,
        i.PrivateCars_value,
        i.PrivateCars_size,
        i.PrivateCars_null);
    }

    // achievementdata_
    //
    {
      char* v =
        o.achievementdata_;

      sqlite::value_traits<
          char[4096],
          sqlite::id_blob >::set_value (
        v,
        i.achievementdata_value,
        i.achievementdata_size,
        i.achievementdata_null);
    }

    // weapondata_
    //
    {
      char* v =
        o.weapondata_;

      sqlite::value_traits<
          char[440],
          sqlite::id_blob >::set_value (
        v,
        i.weapondata_value,
        i.weapondata_size,
        i.weapondata_null);
    }

    // nickname_
    //
    {
      ::std::string& v =
        o.nickname_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.nickname_value,
        i.nickname_size,
        i.nickname_null);
    }
  }

  void access::object_traits_impl< ::user, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    bool grew (false);
    {
      bool is_null (false);
      std::size_t cap (i.id_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.id_value,
        i.id_size,
        is_null,
        id);
      i.id_null = is_null;
      grew = grew || (cap != i.id_value.capacity ());
    }

    if (grew)
      i.version++;
  }

  const char access::object_traits_impl< ::user, id_sqlite >::persist_statement[] =
  "INSERT INTO \"user\" "
  "(\"displayname\", "
  "\"password\", "
  "\"money\", "
  "\"score\", "
  "\"kills\", "
  "\"experience\", "
  "\"deaths\", "
  "\"privilidges\", "
  "\"bounty\", "
  "\"suicides\", "
  "\"respect\", "
  "\"kicks\", "
  "\"warns\", "
  "\"playtime\", "
  "\"banned\", "
  "\"ban_reason\", "
  "\"ban_who\", "
  "\"bannedip\", "
  "\"bannedidentificator\", "
  "\"jailtime\", "
  "\"registertime\", "
  "\"email\", "
  "\"SkinModelID\", "
  "\"Premium\", "
  "\"lastconnected\", "
  "\"MafiaName\", "
  "\"UseMafiaSkin\", "
  "\"UseMafiaSpawn\", "
  "\"rampid\", "
  "\"SaveX\", "
  "\"SaveY\", "
  "\"SaveZ\", "
  "\"SaveA\", "
  "\"staticcolor\", "
  "\"bank\", "
  "\"registerip\", "
  "\"lastip\", "
  "\"recoverycode\", "
  "\"mailverifiedtime\", "
  "\"lastmailsent\", "
  "\"verifiedmail\", "
  "\"verificationsent\", "
  "\"verifiedrecoverycode\", "
  "\"PrivateCars\", "
  "\"achievementdata\", "
  "\"weapondata\", "
  "\"nickname\") "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::user, id_sqlite >::find_statement[] =
  "SELECT "
  "\"user\".\"displayname\", "
  "\"user\".\"password\", "
  "\"user\".\"money\", "
  "\"user\".\"score\", "
  "\"user\".\"kills\", "
  "\"user\".\"experience\", "
  "\"user\".\"deaths\", "
  "\"user\".\"privilidges\", "
  "\"user\".\"bounty\", "
  "\"user\".\"suicides\", "
  "\"user\".\"respect\", "
  "\"user\".\"kicks\", "
  "\"user\".\"warns\", "
  "\"user\".\"playtime\", "
  "\"user\".\"banned\", "
  "\"user\".\"ban_reason\", "
  "\"user\".\"ban_who\", "
  "\"user\".\"bannedip\", "
  "\"user\".\"bannedidentificator\", "
  "\"user\".\"jailtime\", "
  "\"user\".\"registertime\", "
  "\"user\".\"email\", "
  "\"user\".\"SkinModelID\", "
  "\"user\".\"Premium\", "
  "\"user\".\"lastconnected\", "
  "\"user\".\"MafiaName\", "
  "\"user\".\"UseMafiaSkin\", "
  "\"user\".\"UseMafiaSpawn\", "
  "\"user\".\"rampid\", "
  "\"user\".\"SaveX\", "
  "\"user\".\"SaveY\", "
  "\"user\".\"SaveZ\", "
  "\"user\".\"SaveA\", "
  "\"user\".\"staticcolor\", "
  "\"user\".\"bank\", "
  "\"user\".\"registerip\", "
  "\"user\".\"lastip\", "
  "\"user\".\"recoverycode\", "
  "\"user\".\"mailverifiedtime\", "
  "\"user\".\"lastmailsent\", "
  "\"user\".\"verifiedmail\", "
  "\"user\".\"verificationsent\", "
  "\"user\".\"verifiedrecoverycode\", "
  "\"user\".\"PrivateCars\", "
  "\"user\".\"achievementdata\", "
  "\"user\".\"weapondata\", "
  "\"user\".\"nickname\" "
  "FROM \"user\" "
  "WHERE \"user\".\"nickname\"=?";

  const char access::object_traits_impl< ::user, id_sqlite >::update_statement[] =
  "UPDATE \"user\" "
  "SET "
  "\"displayname\"=?, "
  "\"password\"=?, "
  "\"money\"=?, "
  "\"score\"=?, "
  "\"kills\"=?, "
  "\"experience\"=?, "
  "\"deaths\"=?, "
  "\"privilidges\"=?, "
  "\"bounty\"=?, "
  "\"suicides\"=?, "
  "\"respect\"=?, "
  "\"kicks\"=?, "
  "\"warns\"=?, "
  "\"playtime\"=?, "
  "\"banned\"=?, "
  "\"ban_reason\"=?, "
  "\"ban_who\"=?, "
  "\"bannedip\"=?, "
  "\"bannedidentificator\"=?, "
  "\"jailtime\"=?, "
  "\"registertime\"=?, "
  "\"email\"=?, "
  "\"SkinModelID\"=?, "
  "\"Premium\"=?, "
  "\"lastconnected\"=?, "
  "\"MafiaName\"=?, "
  "\"UseMafiaSkin\"=?, "
  "\"UseMafiaSpawn\"=?, "
  "\"rampid\"=?, "
  "\"SaveX\"=?, "
  "\"SaveY\"=?, "
  "\"SaveZ\"=?, "
  "\"SaveA\"=?, "
  "\"staticcolor\"=?, "
  "\"bank\"=?, "
  "\"registerip\"=?, "
  "\"lastip\"=?, "
  "\"recoverycode\"=?, "
  "\"mailverifiedtime\"=?, "
  "\"lastmailsent\"=?, "
  "\"verifiedmail\"=?, "
  "\"verificationsent\"=?, "
  "\"verifiedrecoverycode\"=?, "
  "\"PrivateCars\"=?, "
  "\"achievementdata\"=?, "
  "\"weapondata\"=? "
  "WHERE \"nickname\"=?";

  const char access::object_traits_impl< ::user, id_sqlite >::erase_statement[] =
  "DELETE FROM \"user\" "
  "WHERE \"nickname\"=?";

  const char access::object_traits_impl< ::user, id_sqlite >::query_statement[] =
  "SELECT "
  "\"user\".\"displayname\", "
  "\"user\".\"password\", "
  "\"user\".\"money\", "
  "\"user\".\"score\", "
  "\"user\".\"kills\", "
  "\"user\".\"experience\", "
  "\"user\".\"deaths\", "
  "\"user\".\"privilidges\", "
  "\"user\".\"bounty\", "
  "\"user\".\"suicides\", "
  "\"user\".\"respect\", "
  "\"user\".\"kicks\", "
  "\"user\".\"warns\", "
  "\"user\".\"playtime\", "
  "\"user\".\"banned\", "
  "\"user\".\"ban_reason\", "
  "\"user\".\"ban_who\", "
  "\"user\".\"bannedip\", "
  "\"user\".\"bannedidentificator\", "
  "\"user\".\"jailtime\", "
  "\"user\".\"registertime\", "
  "\"user\".\"email\", "
  "\"user\".\"SkinModelID\", "
  "\"user\".\"Premium\", "
  "\"user\".\"lastconnected\", "
  "\"user\".\"MafiaName\", "
  "\"user\".\"UseMafiaSkin\", "
  "\"user\".\"UseMafiaSpawn\", "
  "\"user\".\"rampid\", "
  "\"user\".\"SaveX\", "
  "\"user\".\"SaveY\", "
  "\"user\".\"SaveZ\", "
  "\"user\".\"SaveA\", "
  "\"user\".\"staticcolor\", "
  "\"user\".\"bank\", "
  "\"user\".\"registerip\", "
  "\"user\".\"lastip\", "
  "\"user\".\"recoverycode\", "
  "\"user\".\"mailverifiedtime\", "
  "\"user\".\"lastmailsent\", "
  "\"user\".\"verifiedmail\", "
  "\"user\".\"verificationsent\", "
  "\"user\".\"verifiedrecoverycode\", "
  "\"user\".\"PrivateCars\", "
  "\"user\".\"achievementdata\", "
  "\"user\".\"weapondata\", "
  "\"user\".\"nickname\" "
  "FROM \"user\"";

  const char access::object_traits_impl< ::user, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"user\"";

  const char access::object_traits_impl< ::user, id_sqlite >::table_name[] =
  "\"user\"";

  void access::object_traits_impl< ::user, id_sqlite >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::user, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;
    using sqlite::update_statement;

    callback (db, obj, callback_event::pre_update);

    sqlite::transaction& tr (sqlite::transaction::current ());
    sqlite::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.nickname_);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::user, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::user, id_sqlite >::pointer_type
  access::object_traits_impl< ::user, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::user, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::user, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.nickname_);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::user, id_sqlite >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::user, id_sqlite >::object_type >
  access::object_traits_impl< ::user, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::user, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // ban
  //

  struct access::object_traits_impl< ::ban, id_sqlite >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      sqlite::connection&,
      image_type&,
      id_image_type&,
      sqlite::binding&,
      sqlite::binding&)
    {
    }
  };

  access::object_traits_impl< ::ban, id_sqlite >::id_type
  access::object_traits_impl< ::ban, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.ip_value,
        i.ip_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::ban, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // bannedtime_
    //
    t[0UL] = false;

    // bannedidentificator_
    //
    t[1UL] = false;

    // banneduser_
    //
    if (t[2UL])
    {
      i.banneduser_value.capacity (i.banneduser_size);
      grew = true;
    }

    // whobannedthisuser_
    //
    if (t[3UL])
    {
      i.whobannedthisuser_value.capacity (i.whobannedthisuser_size);
      grew = true;
    }

    // banreason_
    //
    if (t[4UL])
    {
      i.banreason_value.capacity (i.banreason_size);
      grew = true;
    }

    // ip_
    //
    t[5UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::ban, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // bannedtime_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.bannedtime_value;
    b[n].is_null = &i.bannedtime_null;
    n++;

    // bannedidentificator_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.bannedidentificator_value;
    b[n].is_null = &i.bannedidentificator_null;
    n++;

    // banneduser_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.banneduser_value.data ();
    b[n].size = &i.banneduser_size;
    b[n].capacity = i.banneduser_value.capacity ();
    b[n].is_null = &i.banneduser_null;
    n++;

    // whobannedthisuser_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.whobannedthisuser_value.data ();
    b[n].size = &i.whobannedthisuser_size;
    b[n].capacity = i.whobannedthisuser_value.capacity ();
    b[n].is_null = &i.whobannedthisuser_null;
    n++;

    // banreason_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.banreason_value.data ();
    b[n].size = &i.banreason_size;
    b[n].capacity = i.banreason_value.capacity ();
    b[n].is_null = &i.banreason_null;
    n++;

    // ip_
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.ip_value;
      b[n].is_null = &i.ip_null;
      n++;
    }
  }

  void access::object_traits_impl< ::ban, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::ban, id_sqlite >::
  init (image_type& i,
        const object_type& o,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // bannedtime_
    //
    {
      long long unsigned int const& v =
        o.bannedtime_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.bannedtime_value,
        is_null,
        v);
      i.bannedtime_null = is_null;
    }

    // bannedidentificator_
    //
    {
      long long unsigned int const& v =
        o.bannedidentificator_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.bannedidentificator_value,
        is_null,
        v);
      i.bannedidentificator_null = is_null;
    }

    // banneduser_
    //
    {
      ::std::string const& v =
        o.banneduser_;

      bool is_null (false);
      std::size_t cap (i.banneduser_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.banneduser_value,
        i.banneduser_size,
        is_null,
        v);
      i.banneduser_null = is_null;
      grew = grew || (cap != i.banneduser_value.capacity ());
    }

    // whobannedthisuser_
    //
    {
      ::std::string const& v =
        o.whobannedthisuser_;

      bool is_null (false);
      std::size_t cap (i.whobannedthisuser_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.whobannedthisuser_value,
        i.whobannedthisuser_size,
        is_null,
        v);
      i.whobannedthisuser_null = is_null;
      grew = grew || (cap != i.whobannedthisuser_value.capacity ());
    }

    // banreason_
    //
    {
      ::std::string const& v =
        o.banreason_;

      bool is_null (false);
      std::size_t cap (i.banreason_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.banreason_value,
        i.banreason_size,
        is_null,
        v);
      i.banreason_null = is_null;
      grew = grew || (cap != i.banreason_value.capacity ());
    }

    // ip_
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.ip_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.ip_value,
        is_null,
        v);
      i.ip_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::ban, id_sqlite >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // bannedtime_
    //
    {
      long long unsigned int& v =
        o.bannedtime_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.bannedtime_value,
        i.bannedtime_null);
    }

    // bannedidentificator_
    //
    {
      long long unsigned int& v =
        o.bannedidentificator_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.bannedidentificator_value,
        i.bannedidentificator_null);
    }

    // banneduser_
    //
    {
      ::std::string& v =
        o.banneduser_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.banneduser_value,
        i.banneduser_size,
        i.banneduser_null);
    }

    // whobannedthisuser_
    //
    {
      ::std::string& v =
        o.whobannedthisuser_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.whobannedthisuser_value,
        i.whobannedthisuser_size,
        i.whobannedthisuser_null);
    }

    // banreason_
    //
    {
      ::std::string& v =
        o.banreason_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.banreason_value,
        i.banreason_size,
        i.banreason_null);
    }

    // ip_
    //
    {
      long unsigned int& v =
        o.ip_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.ip_value,
        i.ip_null);
    }
  }

  void access::object_traits_impl< ::ban, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::ban, id_sqlite >::persist_statement[] =
  "INSERT INTO \"ban\" "
  "(\"bannedtime\", "
  "\"bannedidentificator\", "
  "\"banneduser\", "
  "\"whobannedthisuser\", "
  "\"banreason\", "
  "\"ip\") "
  "VALUES "
  "(?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::ban, id_sqlite >::find_statement[] =
  "SELECT "
  "\"ban\".\"bannedtime\", "
  "\"ban\".\"bannedidentificator\", "
  "\"ban\".\"banneduser\", "
  "\"ban\".\"whobannedthisuser\", "
  "\"ban\".\"banreason\", "
  "\"ban\".\"ip\" "
  "FROM \"ban\" "
  "WHERE \"ban\".\"ip\"=?";

  const char access::object_traits_impl< ::ban, id_sqlite >::update_statement[] =
  "UPDATE \"ban\" "
  "SET "
  "\"bannedtime\"=?, "
  "\"bannedidentificator\"=?, "
  "\"banneduser\"=?, "
  "\"whobannedthisuser\"=?, "
  "\"banreason\"=? "
  "WHERE \"ip\"=?";

  const char access::object_traits_impl< ::ban, id_sqlite >::erase_statement[] =
  "DELETE FROM \"ban\" "
  "WHERE \"ip\"=?";

  const char access::object_traits_impl< ::ban, id_sqlite >::query_statement[] =
  "SELECT "
  "\"ban\".\"bannedtime\", "
  "\"ban\".\"bannedidentificator\", "
  "\"ban\".\"banneduser\", "
  "\"ban\".\"whobannedthisuser\", "
  "\"ban\".\"banreason\", "
  "\"ban\".\"ip\" "
  "FROM \"ban\"";

  const char access::object_traits_impl< ::ban, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"ban\"";

  const char access::object_traits_impl< ::ban, id_sqlite >::table_name[] =
  "\"ban\"";

  void access::object_traits_impl< ::ban, id_sqlite >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::ban, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;
    using sqlite::update_statement;

    callback (db, obj, callback_event::pre_update);

    sqlite::transaction& tr (sqlite::transaction::current ());
    sqlite::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.ip_);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::ban, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::ban, id_sqlite >::pointer_type
  access::object_traits_impl< ::ban, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::ban, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::ban, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.ip_);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::ban, id_sqlite >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::ban, id_sqlite >::object_type >
  access::object_traits_impl< ::ban, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::ban, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // mafia
  //

  struct access::object_traits_impl< ::mafia, id_sqlite >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      sqlite::connection&,
      image_type&,
      id_image_type&,
      sqlite::binding&,
      sqlite::binding&)
    {
    }
  };

  access::object_traits_impl< ::mafia, id_sqlite >::id_type
  access::object_traits_impl< ::mafia, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        id,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::mafia, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // displayname_
    //
    if (t[0UL])
    {
      i.displayname_value.capacity (i.displayname_size);
      grew = true;
    }

    // members_
    //
    if (t[1UL])
    {
      i.members_value.capacity (i.members_size);
      grew = true;
    }

    // base_identifier_
    //
    if (t[2UL])
    {
      i.base_identifier_value.capacity (i.base_identifier_size);
      grew = true;
    }

    // last_load_
    //
    t[3UL] = false;

    // action_permissions_
    //
    t[4UL] = false;

    // color_
    //
    t[5UL] = false;

    // money_
    //
    t[6UL] = false;

    // score_
    //
    t[7UL] = false;

    // skin_
    //
    t[8UL] = false;

    // SpawnX_
    //
    t[9UL] = false;

    // SpawnY_
    //
    t[10UL] = false;

    // SpawnZ_
    //
    t[11UL] = false;

    // SpawnA_
    //
    t[12UL] = false;

    // kills_
    //
    t[13UL] = false;

    // deaths_
    //
    t[14UL] = false;

    // experience_
    //
    t[15UL] = false;

    // creation_date_
    //
    t[16UL] = false;

    // playtime_
    //
    t[17UL] = false;

    // tag_
    //
    if (t[18UL])
    {
      i.tag_value.capacity (i.tag_size);
      grew = true;
    }

    // PrivateCars_
    //
    if (t[19UL])
    {
      i.PrivateCars_value.capacity (i.PrivateCars_size);
      grew = true;
    }

    // name_
    //
    if (t[20UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::mafia, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // displayname_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.displayname_value.data ();
    b[n].size = &i.displayname_size;
    b[n].capacity = i.displayname_value.capacity ();
    b[n].is_null = &i.displayname_null;
    n++;

    // members_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.members_value.data ();
    b[n].size = &i.members_size;
    b[n].capacity = i.members_value.capacity ();
    b[n].is_null = &i.members_null;
    n++;

    // base_identifier_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.base_identifier_value.data ();
    b[n].size = &i.base_identifier_size;
    b[n].capacity = i.base_identifier_value.capacity ();
    b[n].is_null = &i.base_identifier_null;
    n++;

    // last_load_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.last_load_value;
    b[n].is_null = &i.last_load_null;
    n++;

    // action_permissions_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.action_permissions_value;
    b[n].is_null = &i.action_permissions_null;
    n++;

    // color_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.color_value;
    b[n].is_null = &i.color_null;
    n++;

    // money_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.money_value;
    b[n].is_null = &i.money_null;
    n++;

    // score_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.score_value;
    b[n].is_null = &i.score_null;
    n++;

    // skin_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.skin_value;
    b[n].is_null = &i.skin_null;
    n++;

    // SpawnX_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.SpawnX_value;
    b[n].is_null = &i.SpawnX_null;
    n++;

    // SpawnY_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.SpawnY_value;
    b[n].is_null = &i.SpawnY_null;
    n++;

    // SpawnZ_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.SpawnZ_value;
    b[n].is_null = &i.SpawnZ_null;
    n++;

    // SpawnA_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.SpawnA_value;
    b[n].is_null = &i.SpawnA_null;
    n++;

    // kills_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.kills_value;
    b[n].is_null = &i.kills_null;
    n++;

    // deaths_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.deaths_value;
    b[n].is_null = &i.deaths_null;
    n++;

    // experience_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.experience_value;
    b[n].is_null = &i.experience_null;
    n++;

    // creation_date_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.creation_date_value;
    b[n].is_null = &i.creation_date_null;
    n++;

    // playtime_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.playtime_value;
    b[n].is_null = &i.playtime_null;
    n++;

    // tag_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.tag_value.data ();
    b[n].size = &i.tag_size;
    b[n].capacity = i.tag_value.capacity ();
    b[n].is_null = &i.tag_null;
    n++;

    // PrivateCars_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.PrivateCars_value.data ();
    b[n].size = &i.PrivateCars_size;
    b[n].capacity = i.PrivateCars_value.capacity ();
    b[n].is_null = &i.PrivateCars_null;
    n++;

    // name_
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::image_traits<
        ::std::string,
        sqlite::id_text>::bind_value;
      b[n].buffer = i.name_value.data ();
      b[n].size = &i.name_size;
      b[n].capacity = i.name_value.capacity ();
      b[n].is_null = &i.name_null;
      n++;
    }
  }

  void access::object_traits_impl< ::mafia, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.id_value.data ();
    b[n].size = &i.id_size;
    b[n].capacity = i.id_value.capacity ();
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::mafia, id_sqlite >::
  init (image_type& i,
        const object_type& o,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // displayname_
    //
    {
      ::std::string const& v =
        o.displayname_;

      bool is_null (false);
      std::size_t cap (i.displayname_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.displayname_value,
        i.displayname_size,
        is_null,
        v);
      i.displayname_null = is_null;
      grew = grew || (cap != i.displayname_value.capacity ());
    }

    // members_
    //
    {
      ::std::string const& v =
        o.members_;

      bool is_null (false);
      std::size_t cap (i.members_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.members_value,
        i.members_size,
        is_null,
        v);
      i.members_null = is_null;
      grew = grew || (cap != i.members_value.capacity ());
    }

    // base_identifier_
    //
    {
      ::std::string const& v =
        o.base_identifier_;

      bool is_null (false);
      std::size_t cap (i.base_identifier_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.base_identifier_value,
        i.base_identifier_size,
        is_null,
        v);
      i.base_identifier_null = is_null;
      grew = grew || (cap != i.base_identifier_value.capacity ());
    }

    // last_load_
    //
    {
      long long unsigned int const& v =
        o.last_load_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.last_load_value,
        is_null,
        v);
      i.last_load_null = is_null;
    }

    // action_permissions_
    //
    {
      long long unsigned int const& v =
        o.action_permissions_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.action_permissions_value,
        is_null,
        v);
      i.action_permissions_null = is_null;
    }

    // color_
    //
    {
      unsigned int const& v =
        o.color_;

      bool is_null (false);
      sqlite::value_traits<
          unsigned int,
          sqlite::id_integer >::set_image (
        i.color_value,
        is_null,
        v);
      i.color_null = is_null;
    }

    // money_
    //
    {
      long long int const& v =
        o.money_;

      bool is_null (false);
      sqlite::value_traits<
          long long int,
          sqlite::id_integer >::set_image (
        i.money_value,
        is_null,
        v);
      i.money_null = is_null;
    }

    // score_
    //
    {
      long long int const& v =
        o.score_;

      bool is_null (false);
      sqlite::value_traits<
          long long int,
          sqlite::id_integer >::set_image (
        i.score_value,
        is_null,
        v);
      i.score_null = is_null;
    }

    // skin_
    //
    {
      int const& v =
        o.skin_;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.skin_value,
        is_null,
        v);
      i.skin_null = is_null;
    }

    // SpawnX_
    //
    {
      float const& v =
        o.SpawnX_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.SpawnX_value,
        is_null,
        v);
      i.SpawnX_null = is_null;
    }

    // SpawnY_
    //
    {
      float const& v =
        o.SpawnY_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.SpawnY_value,
        is_null,
        v);
      i.SpawnY_null = is_null;
    }

    // SpawnZ_
    //
    {
      float const& v =
        o.SpawnZ_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.SpawnZ_value,
        is_null,
        v);
      i.SpawnZ_null = is_null;
    }

    // SpawnA_
    //
    {
      float const& v =
        o.SpawnA_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.SpawnA_value,
        is_null,
        v);
      i.SpawnA_null = is_null;
    }

    // kills_
    //
    {
      long unsigned int const& v =
        o.kills_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.kills_value,
        is_null,
        v);
      i.kills_null = is_null;
    }

    // deaths_
    //
    {
      long unsigned int const& v =
        o.deaths_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.deaths_value,
        is_null,
        v);
      i.deaths_null = is_null;
    }

    // experience_
    //
    {
      long long unsigned int const& v =
        o.experience_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.experience_value,
        is_null,
        v);
      i.experience_null = is_null;
    }

    // creation_date_
    //
    {
      long long unsigned int const& v =
        o.creation_date_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.creation_date_value,
        is_null,
        v);
      i.creation_date_null = is_null;
    }

    // playtime_
    //
    {
      long long unsigned int const& v =
        o.playtime_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.playtime_value,
        is_null,
        v);
      i.playtime_null = is_null;
    }

    // tag_
    //
    {
      ::std::string const& v =
        o.tag_;

      bool is_null (false);
      std::size_t cap (i.tag_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.tag_value,
        i.tag_size,
        is_null,
        v);
      i.tag_null = is_null;
      grew = grew || (cap != i.tag_value.capacity ());
    }

    // PrivateCars_
    //
    {
      char const* v =
        o.PrivateCars_;

      bool is_null (false);
      std::size_t cap (i.PrivateCars_value.capacity ());
      sqlite::value_traits<
          char[144],
          sqlite::id_blob >::set_image (
        i.PrivateCars_value,
        i.PrivateCars_size,
        is_null,
        v);
      i.PrivateCars_null = is_null;
      grew = grew || (cap != i.PrivateCars_value.capacity ());
    }

    // name_
    //
    if (sk == statement_insert)
    {
      ::std::string const& v =
        o.name_;

      bool is_null (false);
      std::size_t cap (i.name_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.name_value,
        i.name_size,
        is_null,
        v);
      i.name_null = is_null;
      grew = grew || (cap != i.name_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::mafia, id_sqlite >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // displayname_
    //
    {
      ::std::string& v =
        o.displayname_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.displayname_value,
        i.displayname_size,
        i.displayname_null);
    }

    // members_
    //
    {
      ::std::string& v =
        o.members_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.members_value,
        i.members_size,
        i.members_null);
    }

    // base_identifier_
    //
    {
      ::std::string& v =
        o.base_identifier_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.base_identifier_value,
        i.base_identifier_size,
        i.base_identifier_null);
    }

    // last_load_
    //
    {
      long long unsigned int& v =
        o.last_load_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.last_load_value,
        i.last_load_null);
    }

    // action_permissions_
    //
    {
      long long unsigned int& v =
        o.action_permissions_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.action_permissions_value,
        i.action_permissions_null);
    }

    // color_
    //
    {
      unsigned int& v =
        o.color_;

      sqlite::value_traits<
          unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.color_value,
        i.color_null);
    }

    // money_
    //
    {
      long long int& v =
        o.money_;

      sqlite::value_traits<
          long long int,
          sqlite::id_integer >::set_value (
        v,
        i.money_value,
        i.money_null);
    }

    // score_
    //
    {
      long long int& v =
        o.score_;

      sqlite::value_traits<
          long long int,
          sqlite::id_integer >::set_value (
        v,
        i.score_value,
        i.score_null);
    }

    // skin_
    //
    {
      int& v =
        o.skin_;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.skin_value,
        i.skin_null);
    }

    // SpawnX_
    //
    {
      float& v =
        o.SpawnX_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.SpawnX_value,
        i.SpawnX_null);
    }

    // SpawnY_
    //
    {
      float& v =
        o.SpawnY_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.SpawnY_value,
        i.SpawnY_null);
    }

    // SpawnZ_
    //
    {
      float& v =
        o.SpawnZ_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.SpawnZ_value,
        i.SpawnZ_null);
    }

    // SpawnA_
    //
    {
      float& v =
        o.SpawnA_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.SpawnA_value,
        i.SpawnA_null);
    }

    // kills_
    //
    {
      long unsigned int& v =
        o.kills_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.kills_value,
        i.kills_null);
    }

    // deaths_
    //
    {
      long unsigned int& v =
        o.deaths_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.deaths_value,
        i.deaths_null);
    }

    // experience_
    //
    {
      long long unsigned int& v =
        o.experience_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.experience_value,
        i.experience_null);
    }

    // creation_date_
    //
    {
      long long unsigned int& v =
        o.creation_date_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.creation_date_value,
        i.creation_date_null);
    }

    // playtime_
    //
    {
      long long unsigned int& v =
        o.playtime_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.playtime_value,
        i.playtime_null);
    }

    // tag_
    //
    {
      ::std::string& v =
        o.tag_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.tag_value,
        i.tag_size,
        i.tag_null);
    }

    // PrivateCars_
    //
    {
      char* v =
        o.PrivateCars_;

      sqlite::value_traits<
          char[144],
          sqlite::id_blob >::set_value (
        v,
        i.PrivateCars_value,
        i.PrivateCars_size,
        i.PrivateCars_null);
    }

    // name_
    //
    {
      ::std::string& v =
        o.name_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }
  }

  void access::object_traits_impl< ::mafia, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    bool grew (false);
    {
      bool is_null (false);
      std::size_t cap (i.id_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.id_value,
        i.id_size,
        is_null,
        id);
      i.id_null = is_null;
      grew = grew || (cap != i.id_value.capacity ());
    }

    if (grew)
      i.version++;
  }

  const char access::object_traits_impl< ::mafia, id_sqlite >::persist_statement[] =
  "INSERT INTO \"mafia\" "
  "(\"displayname\", "
  "\"members\", "
  "\"base_identifier\", "
  "\"last_load\", "
  "\"action_permissions\", "
  "\"color\", "
  "\"money\", "
  "\"score\", "
  "\"skin\", "
  "\"SpawnX\", "
  "\"SpawnY\", "
  "\"SpawnZ\", "
  "\"SpawnA\", "
  "\"kills\", "
  "\"deaths\", "
  "\"experience\", "
  "\"creation_date\", "
  "\"playtime\", "
  "\"tag\", "
  "\"PrivateCars\", "
  "\"name\") "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::mafia, id_sqlite >::find_statement[] =
  "SELECT "
  "\"mafia\".\"displayname\", "
  "\"mafia\".\"members\", "
  "\"mafia\".\"base_identifier\", "
  "\"mafia\".\"last_load\", "
  "\"mafia\".\"action_permissions\", "
  "\"mafia\".\"color\", "
  "\"mafia\".\"money\", "
  "\"mafia\".\"score\", "
  "\"mafia\".\"skin\", "
  "\"mafia\".\"SpawnX\", "
  "\"mafia\".\"SpawnY\", "
  "\"mafia\".\"SpawnZ\", "
  "\"mafia\".\"SpawnA\", "
  "\"mafia\".\"kills\", "
  "\"mafia\".\"deaths\", "
  "\"mafia\".\"experience\", "
  "\"mafia\".\"creation_date\", "
  "\"mafia\".\"playtime\", "
  "\"mafia\".\"tag\", "
  "\"mafia\".\"PrivateCars\", "
  "\"mafia\".\"name\" "
  "FROM \"mafia\" "
  "WHERE \"mafia\".\"name\"=?";

  const char access::object_traits_impl< ::mafia, id_sqlite >::update_statement[] =
  "UPDATE \"mafia\" "
  "SET "
  "\"displayname\"=?, "
  "\"members\"=?, "
  "\"base_identifier\"=?, "
  "\"last_load\"=?, "
  "\"action_permissions\"=?, "
  "\"color\"=?, "
  "\"money\"=?, "
  "\"score\"=?, "
  "\"skin\"=?, "
  "\"SpawnX\"=?, "
  "\"SpawnY\"=?, "
  "\"SpawnZ\"=?, "
  "\"SpawnA\"=?, "
  "\"kills\"=?, "
  "\"deaths\"=?, "
  "\"experience\"=?, "
  "\"creation_date\"=?, "
  "\"playtime\"=?, "
  "\"tag\"=?, "
  "\"PrivateCars\"=? "
  "WHERE \"name\"=?";

  const char access::object_traits_impl< ::mafia, id_sqlite >::erase_statement[] =
  "DELETE FROM \"mafia\" "
  "WHERE \"name\"=?";

  const char access::object_traits_impl< ::mafia, id_sqlite >::query_statement[] =
  "SELECT "
  "\"mafia\".\"displayname\", "
  "\"mafia\".\"members\", "
  "\"mafia\".\"base_identifier\", "
  "\"mafia\".\"last_load\", "
  "\"mafia\".\"action_permissions\", "
  "\"mafia\".\"color\", "
  "\"mafia\".\"money\", "
  "\"mafia\".\"score\", "
  "\"mafia\".\"skin\", "
  "\"mafia\".\"SpawnX\", "
  "\"mafia\".\"SpawnY\", "
  "\"mafia\".\"SpawnZ\", "
  "\"mafia\".\"SpawnA\", "
  "\"mafia\".\"kills\", "
  "\"mafia\".\"deaths\", "
  "\"mafia\".\"experience\", "
  "\"mafia\".\"creation_date\", "
  "\"mafia\".\"playtime\", "
  "\"mafia\".\"tag\", "
  "\"mafia\".\"PrivateCars\", "
  "\"mafia\".\"name\" "
  "FROM \"mafia\"";

  const char access::object_traits_impl< ::mafia, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"mafia\"";

  const char access::object_traits_impl< ::mafia, id_sqlite >::table_name[] =
  "\"mafia\"";

  void access::object_traits_impl< ::mafia, id_sqlite >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::mafia, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;
    using sqlite::update_statement;

    callback (db, obj, callback_event::pre_update);

    sqlite::transaction& tr (sqlite::transaction::current ());
    sqlite::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.name_);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::mafia, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::mafia, id_sqlite >::pointer_type
  access::object_traits_impl< ::mafia, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::mafia, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::mafia, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.name_);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::mafia, id_sqlite >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::mafia, id_sqlite >::object_type >
  access::object_traits_impl< ::mafia, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::mafia, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // house
  //

  struct access::object_traits_impl< ::house, id_sqlite >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      sqlite::connection&,
      image_type&,
      id_image_type&,
      sqlite::binding&,
      sqlite::binding&)
    {
    }
  };

  access::object_traits_impl< ::house, id_sqlite >::id_type
  access::object_traits_impl< ::house, id_sqlite >::
  id (const id_image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  access::object_traits_impl< ::house, id_sqlite >::id_type
  access::object_traits_impl< ::house, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::house, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // world_posX_
    //
    t[0UL] = false;

    // world_posY_
    //
    t[1UL] = false;

    // world_posZ_
    //
    t[2UL] = false;

    // world_angle_
    //
    t[3UL] = false;

    // interior_posX_
    //
    t[4UL] = false;

    // interior_posY_
    //
    t[5UL] = false;

    // interior_posZ_
    //
    t[6UL] = false;

    // interior_angle_
    //
    t[7UL] = false;

    // rented_to_date_
    //
    t[8UL] = false;

    // rent_cost_cash_per_day_
    //
    t[9UL] = false;

    // rent_cost_respect_per_day_
    //
    t[10UL] = false;

    // interiorid_
    //
    t[11UL] = false;

    // rented_to_mafia_
    //
    t[12UL] = false;

    // rented_to_nickname_
    //
    if (t[13UL])
    {
      i.rented_to_nickname_value.capacity (i.rented_to_nickname_size);
      grew = true;
    }

    // locked_
    //
    t[14UL] = false;

    // id_
    //
    t[15UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::house, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // world_posX_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.world_posX_value;
    b[n].is_null = &i.world_posX_null;
    n++;

    // world_posY_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.world_posY_value;
    b[n].is_null = &i.world_posY_null;
    n++;

    // world_posZ_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.world_posZ_value;
    b[n].is_null = &i.world_posZ_null;
    n++;

    // world_angle_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.world_angle_value;
    b[n].is_null = &i.world_angle_null;
    n++;

    // interior_posX_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.interior_posX_value;
    b[n].is_null = &i.interior_posX_null;
    n++;

    // interior_posY_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.interior_posY_value;
    b[n].is_null = &i.interior_posY_null;
    n++;

    // interior_posZ_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.interior_posZ_value;
    b[n].is_null = &i.interior_posZ_null;
    n++;

    // interior_angle_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.interior_angle_value;
    b[n].is_null = &i.interior_angle_null;
    n++;

    // rented_to_date_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.rented_to_date_value;
    b[n].is_null = &i.rented_to_date_null;
    n++;

    // rent_cost_cash_per_day_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.rent_cost_cash_per_day_value;
    b[n].is_null = &i.rent_cost_cash_per_day_null;
    n++;

    // rent_cost_respect_per_day_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.rent_cost_respect_per_day_value;
    b[n].is_null = &i.rent_cost_respect_per_day_null;
    n++;

    // interiorid_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.interiorid_value;
    b[n].is_null = &i.interiorid_null;
    n++;

    // rented_to_mafia_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.rented_to_mafia_value;
    b[n].is_null = &i.rented_to_mafia_null;
    n++;

    // rented_to_nickname_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.rented_to_nickname_value.data ();
    b[n].size = &i.rented_to_nickname_size;
    b[n].capacity = i.rented_to_nickname_value.capacity ();
    b[n].is_null = &i.rented_to_nickname_null;
    n++;

    // locked_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.locked_value;
    b[n].is_null = &i.locked_null;
    n++;

    // id_
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }
  }

  void access::object_traits_impl< ::house, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::house, id_sqlite >::
  init (image_type& i,
        const object_type& o,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // world_posX_
    //
    {
      float const& v =
        o.world_posX_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.world_posX_value,
        is_null,
        v);
      i.world_posX_null = is_null;
    }

    // world_posY_
    //
    {
      float const& v =
        o.world_posY_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.world_posY_value,
        is_null,
        v);
      i.world_posY_null = is_null;
    }

    // world_posZ_
    //
    {
      float const& v =
        o.world_posZ_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.world_posZ_value,
        is_null,
        v);
      i.world_posZ_null = is_null;
    }

    // world_angle_
    //
    {
      float const& v =
        o.world_angle_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.world_angle_value,
        is_null,
        v);
      i.world_angle_null = is_null;
    }

    // interior_posX_
    //
    {
      float const& v =
        o.interior_posX_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.interior_posX_value,
        is_null,
        v);
      i.interior_posX_null = is_null;
    }

    // interior_posY_
    //
    {
      float const& v =
        o.interior_posY_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.interior_posY_value,
        is_null,
        v);
      i.interior_posY_null = is_null;
    }

    // interior_posZ_
    //
    {
      float const& v =
        o.interior_posZ_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.interior_posZ_value,
        is_null,
        v);
      i.interior_posZ_null = is_null;
    }

    // interior_angle_
    //
    {
      float const& v =
        o.interior_angle_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.interior_angle_value,
        is_null,
        v);
      i.interior_angle_null = is_null;
    }

    // rented_to_date_
    //
    {
      long long unsigned int const& v =
        o.rented_to_date_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.rented_to_date_value,
        is_null,
        v);
      i.rented_to_date_null = is_null;
    }

    // rent_cost_cash_per_day_
    //
    {
      long long unsigned int const& v =
        o.rent_cost_cash_per_day_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.rent_cost_cash_per_day_value,
        is_null,
        v);
      i.rent_cost_cash_per_day_null = is_null;
    }

    // rent_cost_respect_per_day_
    //
    {
      long long unsigned int const& v =
        o.rent_cost_respect_per_day_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.rent_cost_respect_per_day_value,
        is_null,
        v);
      i.rent_cost_respect_per_day_null = is_null;
    }

    // interiorid_
    //
    {
      int const& v =
        o.interiorid_;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.interiorid_value,
        is_null,
        v);
      i.interiorid_null = is_null;
    }

    // rented_to_mafia_
    //
    {
      bool const& v =
        o.rented_to_mafia_;

      bool is_null (false);
      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_image (
        i.rented_to_mafia_value,
        is_null,
        v);
      i.rented_to_mafia_null = is_null;
    }

    // rented_to_nickname_
    //
    {
      ::std::string const& v =
        o.rented_to_nickname_;

      bool is_null (false);
      std::size_t cap (i.rented_to_nickname_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.rented_to_nickname_value,
        i.rented_to_nickname_size,
        is_null,
        v);
      i.rented_to_nickname_null = is_null;
      grew = grew || (cap != i.rented_to_nickname_value.capacity ());
    }

    // locked_
    //
    {
      bool const& v =
        o.locked_;

      bool is_null (false);
      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_image (
        i.locked_value,
        is_null,
        v);
      i.locked_null = is_null;
    }

    // id_
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.id_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        v);
      i.id_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::house, id_sqlite >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // world_posX_
    //
    {
      float& v =
        o.world_posX_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.world_posX_value,
        i.world_posX_null);
    }

    // world_posY_
    //
    {
      float& v =
        o.world_posY_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.world_posY_value,
        i.world_posY_null);
    }

    // world_posZ_
    //
    {
      float& v =
        o.world_posZ_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.world_posZ_value,
        i.world_posZ_null);
    }

    // world_angle_
    //
    {
      float& v =
        o.world_angle_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.world_angle_value,
        i.world_angle_null);
    }

    // interior_posX_
    //
    {
      float& v =
        o.interior_posX_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.interior_posX_value,
        i.interior_posX_null);
    }

    // interior_posY_
    //
    {
      float& v =
        o.interior_posY_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.interior_posY_value,
        i.interior_posY_null);
    }

    // interior_posZ_
    //
    {
      float& v =
        o.interior_posZ_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.interior_posZ_value,
        i.interior_posZ_null);
    }

    // interior_angle_
    //
    {
      float& v =
        o.interior_angle_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.interior_angle_value,
        i.interior_angle_null);
    }

    // rented_to_date_
    //
    {
      long long unsigned int& v =
        o.rented_to_date_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.rented_to_date_value,
        i.rented_to_date_null);
    }

    // rent_cost_cash_per_day_
    //
    {
      long long unsigned int& v =
        o.rent_cost_cash_per_day_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.rent_cost_cash_per_day_value,
        i.rent_cost_cash_per_day_null);
    }

    // rent_cost_respect_per_day_
    //
    {
      long long unsigned int& v =
        o.rent_cost_respect_per_day_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.rent_cost_respect_per_day_value,
        i.rent_cost_respect_per_day_null);
    }

    // interiorid_
    //
    {
      int& v =
        o.interiorid_;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.interiorid_value,
        i.interiorid_null);
    }

    // rented_to_mafia_
    //
    {
      bool& v =
        o.rented_to_mafia_;

      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_value (
        v,
        i.rented_to_mafia_value,
        i.rented_to_mafia_null);
    }

    // rented_to_nickname_
    //
    {
      ::std::string& v =
        o.rented_to_nickname_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.rented_to_nickname_value,
        i.rented_to_nickname_size,
        i.rented_to_nickname_null);
    }

    // locked_
    //
    {
      bool& v =
        o.locked_;

      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_value (
        v,
        i.locked_value,
        i.locked_null);
    }

    // id_
    //
    {
      long unsigned int& v =
        o.id_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.id_value,
        i.id_null);
    }
  }

  void access::object_traits_impl< ::house, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::house, id_sqlite >::persist_statement[] =
  "INSERT INTO \"house\" "
  "(\"world_posX\", "
  "\"world_posY\", "
  "\"world_posZ\", "
  "\"world_angle\", "
  "\"interior_posX\", "
  "\"interior_posY\", "
  "\"interior_posZ\", "
  "\"interior_angle\", "
  "\"rented_to_date\", "
  "\"rent_cost_cash_per_day\", "
  "\"rent_cost_respect_per_day\", "
  "\"interiorid\", "
  "\"rented_to_mafia\", "
  "\"rented_to_nickname\", "
  "\"locked\", "
  "\"id\") "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::house, id_sqlite >::find_statement[] =
  "SELECT "
  "\"house\".\"world_posX\", "
  "\"house\".\"world_posY\", "
  "\"house\".\"world_posZ\", "
  "\"house\".\"world_angle\", "
  "\"house\".\"interior_posX\", "
  "\"house\".\"interior_posY\", "
  "\"house\".\"interior_posZ\", "
  "\"house\".\"interior_angle\", "
  "\"house\".\"rented_to_date\", "
  "\"house\".\"rent_cost_cash_per_day\", "
  "\"house\".\"rent_cost_respect_per_day\", "
  "\"house\".\"interiorid\", "
  "\"house\".\"rented_to_mafia\", "
  "\"house\".\"rented_to_nickname\", "
  "\"house\".\"locked\", "
  "\"house\".\"id\" "
  "FROM \"house\" "
  "WHERE \"house\".\"id\"=?";

  const char access::object_traits_impl< ::house, id_sqlite >::update_statement[] =
  "UPDATE \"house\" "
  "SET "
  "\"world_posX\"=?, "
  "\"world_posY\"=?, "
  "\"world_posZ\"=?, "
  "\"world_angle\"=?, "
  "\"interior_posX\"=?, "
  "\"interior_posY\"=?, "
  "\"interior_posZ\"=?, "
  "\"interior_angle\"=?, "
  "\"rented_to_date\"=?, "
  "\"rent_cost_cash_per_day\"=?, "
  "\"rent_cost_respect_per_day\"=?, "
  "\"interiorid\"=?, "
  "\"rented_to_mafia\"=?, "
  "\"rented_to_nickname\"=?, "
  "\"locked\"=? "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::house, id_sqlite >::erase_statement[] =
  "DELETE FROM \"house\" "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::house, id_sqlite >::query_statement[] =
  "SELECT "
  "\"house\".\"world_posX\", "
  "\"house\".\"world_posY\", "
  "\"house\".\"world_posZ\", "
  "\"house\".\"world_angle\", "
  "\"house\".\"interior_posX\", "
  "\"house\".\"interior_posY\", "
  "\"house\".\"interior_posZ\", "
  "\"house\".\"interior_angle\", "
  "\"house\".\"rented_to_date\", "
  "\"house\".\"rent_cost_cash_per_day\", "
  "\"house\".\"rent_cost_respect_per_day\", "
  "\"house\".\"interiorid\", "
  "\"house\".\"rented_to_mafia\", "
  "\"house\".\"rented_to_nickname\", "
  "\"house\".\"locked\", "
  "\"house\".\"id\" "
  "FROM \"house\"";

  const char access::object_traits_impl< ::house, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"house\"";

  const char access::object_traits_impl< ::house, id_sqlite >::table_name[] =
  "\"house\"";

  void access::object_traits_impl< ::house, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    {
      id_image_type& i (sts.id_image ());
      binding& b (sts.id_image_binding ());
      if (i.version != sts.id_image_version () || b.version == 0)
      {
        bind (b.bind, i);
        sts.id_image_version (i.version);
        b.version++;
      }
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id_ = id (sts.id_image ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::house, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;
    using sqlite::update_statement;

    callback (db, obj, callback_event::pre_update);

    sqlite::transaction& tr (sqlite::transaction::current ());
    sqlite::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id_);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::house, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::house, id_sqlite >::pointer_type
  access::object_traits_impl< ::house, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::house, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::house, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id_);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::house, id_sqlite >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::house, id_sqlite >::object_type >
  access::object_traits_impl< ::house, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::house, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // sentrygun
  //

  struct access::object_traits_impl< ::sentrygun, id_sqlite >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      sqlite::connection&,
      image_type&,
      id_image_type&,
      sqlite::binding&,
      sqlite::binding&)
    {
    }
  };

  access::object_traits_impl< ::sentrygun, id_sqlite >::id_type
  access::object_traits_impl< ::sentrygun, id_sqlite >::
  id (const id_image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  access::object_traits_impl< ::sentrygun, id_sqlite >::id_type
  access::object_traits_impl< ::sentrygun, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::sentrygun, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // posX_
    //
    t[0UL] = false;

    // posY_
    //
    t[1UL] = false;

    // posZ_
    //
    t[2UL] = false;

    // angle_
    //
    t[3UL] = false;

    // area_a_X_
    //
    t[4UL] = false;

    // area_a_Y_
    //
    t[5UL] = false;

    // area_a_Z_
    //
    t[6UL] = false;

    // area_b_X_
    //
    t[7UL] = false;

    // area_b_Y_
    //
    t[8UL] = false;

    // area_b_Z_
    //
    t[9UL] = false;

    // interiorid_
    //
    t[10UL] = false;

    // worldid_
    //
    t[11UL] = false;

    // owner_status_
    //
    t[12UL] = false;

    // owner_name_
    //
    if (t[13UL])
    {
      i.owner_name_value.capacity (i.owner_name_size);
      grew = true;
    }

    // experience_
    //
    t[14UL] = false;

    // respect_
    //
    t[15UL] = false;

    // KilledVehicles_
    //
    t[16UL] = false;

    // KilledPlayers_
    //
    t[17UL] = false;

    // Destroyed_
    //
    t[18UL] = false;

    // deactivated_
    //
    t[19UL] = false;

    // id_
    //
    t[20UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::sentrygun, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // posX_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.posX_value;
    b[n].is_null = &i.posX_null;
    n++;

    // posY_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.posY_value;
    b[n].is_null = &i.posY_null;
    n++;

    // posZ_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.posZ_value;
    b[n].is_null = &i.posZ_null;
    n++;

    // angle_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.angle_value;
    b[n].is_null = &i.angle_null;
    n++;

    // area_a_X_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.area_a_X_value;
    b[n].is_null = &i.area_a_X_null;
    n++;

    // area_a_Y_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.area_a_Y_value;
    b[n].is_null = &i.area_a_Y_null;
    n++;

    // area_a_Z_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.area_a_Z_value;
    b[n].is_null = &i.area_a_Z_null;
    n++;

    // area_b_X_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.area_b_X_value;
    b[n].is_null = &i.area_b_X_null;
    n++;

    // area_b_Y_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.area_b_Y_value;
    b[n].is_null = &i.area_b_Y_null;
    n++;

    // area_b_Z_
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.area_b_Z_value;
    b[n].is_null = &i.area_b_Z_null;
    n++;

    // interiorid_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.interiorid_value;
    b[n].is_null = &i.interiorid_null;
    n++;

    // worldid_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.worldid_value;
    b[n].is_null = &i.worldid_null;
    n++;

    // owner_status_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.owner_status_value;
    b[n].is_null = &i.owner_status_null;
    n++;

    // owner_name_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.owner_name_value.data ();
    b[n].size = &i.owner_name_size;
    b[n].capacity = i.owner_name_value.capacity ();
    b[n].is_null = &i.owner_name_null;
    n++;

    // experience_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.experience_value;
    b[n].is_null = &i.experience_null;
    n++;

    // respect_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.respect_value;
    b[n].is_null = &i.respect_null;
    n++;

    // KilledVehicles_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.KilledVehicles_value;
    b[n].is_null = &i.KilledVehicles_null;
    n++;

    // KilledPlayers_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.KilledPlayers_value;
    b[n].is_null = &i.KilledPlayers_null;
    n++;

    // Destroyed_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.Destroyed_value;
    b[n].is_null = &i.Destroyed_null;
    n++;

    // deactivated_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.deactivated_value;
    b[n].is_null = &i.deactivated_null;
    n++;

    // id_
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }
  }

  void access::object_traits_impl< ::sentrygun, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::sentrygun, id_sqlite >::
  init (image_type& i,
        const object_type& o,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // posX_
    //
    {
      float const& v =
        o.posX_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.posX_value,
        is_null,
        v);
      i.posX_null = is_null;
    }

    // posY_
    //
    {
      float const& v =
        o.posY_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.posY_value,
        is_null,
        v);
      i.posY_null = is_null;
    }

    // posZ_
    //
    {
      float const& v =
        o.posZ_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.posZ_value,
        is_null,
        v);
      i.posZ_null = is_null;
    }

    // angle_
    //
    {
      float const& v =
        o.angle_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.angle_value,
        is_null,
        v);
      i.angle_null = is_null;
    }

    // area_a_X_
    //
    {
      float const& v =
        o.area_a_X_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.area_a_X_value,
        is_null,
        v);
      i.area_a_X_null = is_null;
    }

    // area_a_Y_
    //
    {
      float const& v =
        o.area_a_Y_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.area_a_Y_value,
        is_null,
        v);
      i.area_a_Y_null = is_null;
    }

    // area_a_Z_
    //
    {
      float const& v =
        o.area_a_Z_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.area_a_Z_value,
        is_null,
        v);
      i.area_a_Z_null = is_null;
    }

    // area_b_X_
    //
    {
      float const& v =
        o.area_b_X_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.area_b_X_value,
        is_null,
        v);
      i.area_b_X_null = is_null;
    }

    // area_b_Y_
    //
    {
      float const& v =
        o.area_b_Y_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.area_b_Y_value,
        is_null,
        v);
      i.area_b_Y_null = is_null;
    }

    // area_b_Z_
    //
    {
      float const& v =
        o.area_b_Z_;

      bool is_null (true);
      sqlite::value_traits<
          float,
          sqlite::id_real >::set_image (
        i.area_b_Z_value,
        is_null,
        v);
      i.area_b_Z_null = is_null;
    }

    // interiorid_
    //
    {
      int const& v =
        o.interiorid_;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.interiorid_value,
        is_null,
        v);
      i.interiorid_null = is_null;
    }

    // worldid_
    //
    {
      int const& v =
        o.worldid_;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.worldid_value,
        is_null,
        v);
      i.worldid_null = is_null;
    }

    // owner_status_
    //
    {
      int const& v =
        o.owner_status_;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.owner_status_value,
        is_null,
        v);
      i.owner_status_null = is_null;
    }

    // owner_name_
    //
    {
      ::std::string const& v =
        o.owner_name_;

      bool is_null (false);
      std::size_t cap (i.owner_name_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.owner_name_value,
        i.owner_name_size,
        is_null,
        v);
      i.owner_name_null = is_null;
      grew = grew || (cap != i.owner_name_value.capacity ());
    }

    // experience_
    //
    {
      long long unsigned int const& v =
        o.experience_;

      bool is_null (false);
      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_image (
        i.experience_value,
        is_null,
        v);
      i.experience_null = is_null;
    }

    // respect_
    //
    {
      long long int const& v =
        o.respect_;

      bool is_null (false);
      sqlite::value_traits<
          long long int,
          sqlite::id_integer >::set_image (
        i.respect_value,
        is_null,
        v);
      i.respect_null = is_null;
    }

    // KilledVehicles_
    //
    {
      long unsigned int const& v =
        o.KilledVehicles_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.KilledVehicles_value,
        is_null,
        v);
      i.KilledVehicles_null = is_null;
    }

    // KilledPlayers_
    //
    {
      long unsigned int const& v =
        o.KilledPlayers_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.KilledPlayers_value,
        is_null,
        v);
      i.KilledPlayers_null = is_null;
    }

    // Destroyed_
    //
    {
      long unsigned int const& v =
        o.Destroyed_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.Destroyed_value,
        is_null,
        v);
      i.Destroyed_null = is_null;
    }

    // deactivated_
    //
    {
      bool const& v =
        o.deactivated_;

      bool is_null (false);
      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_image (
        i.deactivated_value,
        is_null,
        v);
      i.deactivated_null = is_null;
    }

    // id_
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.id_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        v);
      i.id_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::sentrygun, id_sqlite >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // posX_
    //
    {
      float& v =
        o.posX_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.posX_value,
        i.posX_null);
    }

    // posY_
    //
    {
      float& v =
        o.posY_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.posY_value,
        i.posY_null);
    }

    // posZ_
    //
    {
      float& v =
        o.posZ_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.posZ_value,
        i.posZ_null);
    }

    // angle_
    //
    {
      float& v =
        o.angle_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.angle_value,
        i.angle_null);
    }

    // area_a_X_
    //
    {
      float& v =
        o.area_a_X_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.area_a_X_value,
        i.area_a_X_null);
    }

    // area_a_Y_
    //
    {
      float& v =
        o.area_a_Y_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.area_a_Y_value,
        i.area_a_Y_null);
    }

    // area_a_Z_
    //
    {
      float& v =
        o.area_a_Z_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.area_a_Z_value,
        i.area_a_Z_null);
    }

    // area_b_X_
    //
    {
      float& v =
        o.area_b_X_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.area_b_X_value,
        i.area_b_X_null);
    }

    // area_b_Y_
    //
    {
      float& v =
        o.area_b_Y_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.area_b_Y_value,
        i.area_b_Y_null);
    }

    // area_b_Z_
    //
    {
      float& v =
        o.area_b_Z_;

      sqlite::value_traits<
          float,
          sqlite::id_real >::set_value (
        v,
        i.area_b_Z_value,
        i.area_b_Z_null);
    }

    // interiorid_
    //
    {
      int& v =
        o.interiorid_;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.interiorid_value,
        i.interiorid_null);
    }

    // worldid_
    //
    {
      int& v =
        o.worldid_;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.worldid_value,
        i.worldid_null);
    }

    // owner_status_
    //
    {
      int& v =
        o.owner_status_;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.owner_status_value,
        i.owner_status_null);
    }

    // owner_name_
    //
    {
      ::std::string& v =
        o.owner_name_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.owner_name_value,
        i.owner_name_size,
        i.owner_name_null);
    }

    // experience_
    //
    {
      long long unsigned int& v =
        o.experience_;

      sqlite::value_traits<
          long long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.experience_value,
        i.experience_null);
    }

    // respect_
    //
    {
      long long int& v =
        o.respect_;

      sqlite::value_traits<
          long long int,
          sqlite::id_integer >::set_value (
        v,
        i.respect_value,
        i.respect_null);
    }

    // KilledVehicles_
    //
    {
      long unsigned int& v =
        o.KilledVehicles_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.KilledVehicles_value,
        i.KilledVehicles_null);
    }

    // KilledPlayers_
    //
    {
      long unsigned int& v =
        o.KilledPlayers_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.KilledPlayers_value,
        i.KilledPlayers_null);
    }

    // Destroyed_
    //
    {
      long unsigned int& v =
        o.Destroyed_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.Destroyed_value,
        i.Destroyed_null);
    }

    // deactivated_
    //
    {
      bool& v =
        o.deactivated_;

      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_value (
        v,
        i.deactivated_value,
        i.deactivated_null);
    }

    // id_
    //
    {
      long unsigned int& v =
        o.id_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.id_value,
        i.id_null);
    }
  }

  void access::object_traits_impl< ::sentrygun, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::sentrygun, id_sqlite >::persist_statement[] =
  "INSERT INTO \"sentrygun\" "
  "(\"posX\", "
  "\"posY\", "
  "\"posZ\", "
  "\"angle\", "
  "\"area_a_X\", "
  "\"area_a_Y\", "
  "\"area_a_Z\", "
  "\"area_b_X\", "
  "\"area_b_Y\", "
  "\"area_b_Z\", "
  "\"interiorid\", "
  "\"worldid\", "
  "\"owner_status\", "
  "\"owner_name\", "
  "\"experience\", "
  "\"respect\", "
  "\"KilledVehicles\", "
  "\"KilledPlayers\", "
  "\"Destroyed\", "
  "\"deactivated\", "
  "\"id\") "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::sentrygun, id_sqlite >::find_statement[] =
  "SELECT "
  "\"sentrygun\".\"posX\", "
  "\"sentrygun\".\"posY\", "
  "\"sentrygun\".\"posZ\", "
  "\"sentrygun\".\"angle\", "
  "\"sentrygun\".\"area_a_X\", "
  "\"sentrygun\".\"area_a_Y\", "
  "\"sentrygun\".\"area_a_Z\", "
  "\"sentrygun\".\"area_b_X\", "
  "\"sentrygun\".\"area_b_Y\", "
  "\"sentrygun\".\"area_b_Z\", "
  "\"sentrygun\".\"interiorid\", "
  "\"sentrygun\".\"worldid\", "
  "\"sentrygun\".\"owner_status\", "
  "\"sentrygun\".\"owner_name\", "
  "\"sentrygun\".\"experience\", "
  "\"sentrygun\".\"respect\", "
  "\"sentrygun\".\"KilledVehicles\", "
  "\"sentrygun\".\"KilledPlayers\", "
  "\"sentrygun\".\"Destroyed\", "
  "\"sentrygun\".\"deactivated\", "
  "\"sentrygun\".\"id\" "
  "FROM \"sentrygun\" "
  "WHERE \"sentrygun\".\"id\"=?";

  const char access::object_traits_impl< ::sentrygun, id_sqlite >::update_statement[] =
  "UPDATE \"sentrygun\" "
  "SET "
  "\"posX\"=?, "
  "\"posY\"=?, "
  "\"posZ\"=?, "
  "\"angle\"=?, "
  "\"area_a_X\"=?, "
  "\"area_a_Y\"=?, "
  "\"area_a_Z\"=?, "
  "\"area_b_X\"=?, "
  "\"area_b_Y\"=?, "
  "\"area_b_Z\"=?, "
  "\"interiorid\"=?, "
  "\"worldid\"=?, "
  "\"owner_status\"=?, "
  "\"owner_name\"=?, "
  "\"experience\"=?, "
  "\"respect\"=?, "
  "\"KilledVehicles\"=?, "
  "\"KilledPlayers\"=?, "
  "\"Destroyed\"=?, "
  "\"deactivated\"=? "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::sentrygun, id_sqlite >::erase_statement[] =
  "DELETE FROM \"sentrygun\" "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::sentrygun, id_sqlite >::query_statement[] =
  "SELECT "
  "\"sentrygun\".\"posX\", "
  "\"sentrygun\".\"posY\", "
  "\"sentrygun\".\"posZ\", "
  "\"sentrygun\".\"angle\", "
  "\"sentrygun\".\"area_a_X\", "
  "\"sentrygun\".\"area_a_Y\", "
  "\"sentrygun\".\"area_a_Z\", "
  "\"sentrygun\".\"area_b_X\", "
  "\"sentrygun\".\"area_b_Y\", "
  "\"sentrygun\".\"area_b_Z\", "
  "\"sentrygun\".\"interiorid\", "
  "\"sentrygun\".\"worldid\", "
  "\"sentrygun\".\"owner_status\", "
  "\"sentrygun\".\"owner_name\", "
  "\"sentrygun\".\"experience\", "
  "\"sentrygun\".\"respect\", "
  "\"sentrygun\".\"KilledVehicles\", "
  "\"sentrygun\".\"KilledPlayers\", "
  "\"sentrygun\".\"Destroyed\", "
  "\"sentrygun\".\"deactivated\", "
  "\"sentrygun\".\"id\" "
  "FROM \"sentrygun\"";

  const char access::object_traits_impl< ::sentrygun, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"sentrygun\"";

  const char access::object_traits_impl< ::sentrygun, id_sqlite >::table_name[] =
  "\"sentrygun\"";

  void access::object_traits_impl< ::sentrygun, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    {
      id_image_type& i (sts.id_image ());
      binding& b (sts.id_image_binding ());
      if (i.version != sts.id_image_version () || b.version == 0)
      {
        bind (b.bind, i);
        sts.id_image_version (i.version);
        b.version++;
      }
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id_ = id (sts.id_image ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::sentrygun, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;
    using sqlite::update_statement;

    callback (db, obj, callback_event::pre_update);

    sqlite::transaction& tr (sqlite::transaction::current ());
    sqlite::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id_);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::sentrygun, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::sentrygun, id_sqlite >::pointer_type
  access::object_traits_impl< ::sentrygun, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::sentrygun, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::sentrygun, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id_);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::sentrygun, id_sqlite >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::sentrygun, id_sqlite >::object_type >
  access::object_traits_impl< ::sentrygun, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::sentrygun, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }
}

namespace odb
{
  static bool
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          return true;
        }
        case 2:
        {
          db.execute ("DROP TABLE IF EXISTS \"sentrygun\"");
          db.execute ("DROP TABLE IF EXISTS \"house\"");
          db.execute ("DROP TABLE IF EXISTS \"mafia\"");
          db.execute ("DROP TABLE IF EXISTS \"ban\"");
          db.execute ("DROP TABLE IF EXISTS \"user\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"user\" (\n"
                      "  \"displayname\" TEXT NULL,\n"
                      "  \"password\" TEXT NULL,\n"
                      "  \"money\" INTEGER NULL,\n"
                      "  \"score\" INTEGER NULL,\n"
                      "  \"kills\" INTEGER NULL,\n"
                      "  \"experience\" INTEGER NULL,\n"
                      "  \"deaths\" INTEGER NULL,\n"
                      "  \"privilidges\" INTEGER NULL,\n"
                      "  \"bounty\" INTEGER NULL,\n"
                      "  \"suicides\" INTEGER NULL,\n"
                      "  \"respect\" INTEGER NULL,\n"
                      "  \"kicks\" INTEGER NULL,\n"
                      "  \"warns\" INTEGER NULL,\n"
                      "  \"playtime\" INTEGER NULL,\n"
                      "  \"banned\" INTEGER NULL,\n"
                      "  \"ban_reason\" TEXT NULL,\n"
                      "  \"ban_who\" TEXT NULL,\n"
                      "  \"bannedip\" INTEGER NULL,\n"
                      "  \"bannedidentificator\" INTEGER NULL,\n"
                      "  \"jailtime\" INTEGER NULL,\n"
                      "  \"registertime\" INTEGER NULL,\n"
                      "  \"email\" TEXT NULL,\n"
                      "  \"SkinModelID\" INTEGER NULL,\n"
                      "  \"Premium\" INTEGER NULL,\n"
                      "  \"lastconnected\" INTEGER NULL,\n"
                      "  \"MafiaName\" TEXT NULL,\n"
                      "  \"UseMafiaSkin\" INTEGER NULL,\n"
                      "  \"UseMafiaSpawn\" INTEGER NULL,\n"
                      "  \"rampid\" INTEGER NULL,\n"
                      "  \"SaveX\" REAL NULL,\n"
                      "  \"SaveY\" REAL NULL,\n"
                      "  \"SaveZ\" REAL NULL,\n"
                      "  \"SaveA\" REAL NULL,\n"
                      "  \"staticcolor\" INTEGER NULL,\n"
                      "  \"bank\" INTEGER NULL,\n"
                      "  \"registerip\" TEXT NULL,\n"
                      "  \"lastip\" TEXT NULL,\n"
                      "  \"recoverycode\" TEXT NULL,\n"
                      "  \"mailverifiedtime\" INTEGER NULL,\n"
                      "  \"lastmailsent\" INTEGER NULL,\n"
                      "  \"verifiedmail\" TEXT NULL,\n"
                      "  \"verificationsent\" INTEGER NULL,\n"
                      "  \"verifiedrecoverycode\" TEXT NULL,\n"
                      "  \"PrivateCars\" BLOB NULL,\n"
                      "  \"achievementdata\" BLOB NULL,\n"
                      "  \"weapondata\" BLOB NULL,\n"
                      "  \"nickname\" TEXT NULL PRIMARY KEY)");
          db.execute ("CREATE UNIQUE INDEX \"user_nickname_i\"\n"
                      "  ON \"user\" (\"nickname\")");
          db.execute ("CREATE TABLE \"ban\" (\n"
                      "  \"bannedtime\" INTEGER NULL,\n"
                      "  \"bannedidentificator\" INTEGER NULL,\n"
                      "  \"banneduser\" TEXT NULL,\n"
                      "  \"whobannedthisuser\" TEXT NULL,\n"
                      "  \"banreason\" TEXT NULL,\n"
                      "  \"ip\" INTEGER NULL PRIMARY KEY)");
          db.execute ("CREATE UNIQUE INDEX \"ban_ip_i\"\n"
                      "  ON \"ban\" (\"ip\")");
          db.execute ("CREATE TABLE \"mafia\" (\n"
                      "  \"displayname\" TEXT NULL,\n"
                      "  \"members\" VARCHAR(4096) NULL,\n"
                      "  \"base_identifier\" TEXT NULL,\n"
                      "  \"last_load\" INTEGER NULL,\n"
                      "  \"action_permissions\" INTEGER NULL,\n"
                      "  \"color\" INTEGER NULL,\n"
                      "  \"money\" INTEGER NULL,\n"
                      "  \"score\" INTEGER NULL,\n"
                      "  \"skin\" INTEGER NULL,\n"
                      "  \"SpawnX\" REAL NULL,\n"
                      "  \"SpawnY\" REAL NULL,\n"
                      "  \"SpawnZ\" REAL NULL,\n"
                      "  \"SpawnA\" REAL NULL,\n"
                      "  \"kills\" INTEGER NULL,\n"
                      "  \"deaths\" INTEGER NULL,\n"
                      "  \"experience\" INTEGER NULL,\n"
                      "  \"creation_date\" INTEGER NULL,\n"
                      "  \"playtime\" INTEGER NULL,\n"
                      "  \"tag\" TEXT NULL,\n"
                      "  \"PrivateCars\" BLOB NULL,\n"
                      "  \"name\" TEXT NULL PRIMARY KEY)");
          db.execute ("CREATE UNIQUE INDEX \"mafia_name_i\"\n"
                      "  ON \"mafia\" (\"name\")");
          db.execute ("CREATE TABLE \"house\" (\n"
                      "  \"world_posX\" REAL NULL,\n"
                      "  \"world_posY\" REAL NULL,\n"
                      "  \"world_posZ\" REAL NULL,\n"
                      "  \"world_angle\" REAL NULL,\n"
                      "  \"interior_posX\" REAL NULL,\n"
                      "  \"interior_posY\" REAL NULL,\n"
                      "  \"interior_posZ\" REAL NULL,\n"
                      "  \"interior_angle\" REAL NULL,\n"
                      "  \"rented_to_date\" INTEGER NULL,\n"
                      "  \"rent_cost_cash_per_day\" INTEGER NULL,\n"
                      "  \"rent_cost_respect_per_day\" INTEGER NULL,\n"
                      "  \"interiorid\" INTEGER NULL,\n"
                      "  \"rented_to_mafia\" INTEGER NULL,\n"
                      "  \"rented_to_nickname\" TEXT NULL,\n"
                      "  \"locked\" INTEGER NULL,\n"
                      "  \"id\" INTEGER NULL PRIMARY KEY AUTOINCREMENT)");
          db.execute ("CREATE TABLE \"sentrygun\" (\n"
                      "  \"posX\" REAL NULL,\n"
                      "  \"posY\" REAL NULL,\n"
                      "  \"posZ\" REAL NULL,\n"
                      "  \"angle\" REAL NULL,\n"
                      "  \"area_a_X\" REAL NULL,\n"
                      "  \"area_a_Y\" REAL NULL,\n"
                      "  \"area_a_Z\" REAL NULL,\n"
                      "  \"area_b_X\" REAL NULL,\n"
                      "  \"area_b_Y\" REAL NULL,\n"
                      "  \"area_b_Z\" REAL NULL,\n"
                      "  \"interiorid\" INTEGER NULL,\n"
                      "  \"worldid\" INTEGER NULL,\n"
                      "  \"owner_status\" INTEGER NULL,\n"
                      "  \"owner_name\" TEXT NULL,\n"
                      "  \"experience\" INTEGER NULL,\n"
                      "  \"respect\" INTEGER NULL,\n"
                      "  \"KilledVehicles\" INTEGER NULL,\n"
                      "  \"KilledPlayers\" INTEGER NULL,\n"
                      "  \"Destroyed\" INTEGER NULL,\n"
                      "  \"deactivated\" INTEGER NULL,\n"
                      "  \"id\" INTEGER NULL PRIMARY KEY AUTOINCREMENT)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_create_entry
  create_schema_entry_ (
    id_sqlite,
    "",
    &create_schema);
}

#include <odb/post.hxx>
